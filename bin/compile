#!/usr/bin/env bash
# usage: bin/compile BUILD_DIR CACHE_DIR ENV_DIR

set -e -o pipefail

# sed -l basically makes sed replace and buffer through stdin to
# stdout so you get updates while the command runs and don't wait for
# the end.
# e.g. npm install | indent
# lifted from: https://github.com/heroku/heroku-buildpack-jvm-common
indent() {
  # if an arg is given it's a flag indicating we shouldn't indent the
  # first line, so use :+ to tell SED accordingly if that parameter is
  # set, otherwise null string for no range selector prefix (it
  # selects from line 2 onwards and then every 1st line, meaning all
  # lines)
  c="${1:+"2,999"} s/^/       /"
  case $(uname) in
    Darwin) sed -l "$c";; # mac/bsd sed: -l buffers on line boundaries
    *)      sed -u "$c";; # unix/gnu sed: -u unbuffered (arbitrary) chunks of data
  esac
}
# from https://github.com/pandeiro/heroku-buildpack-boot/blob/master/bin/compile#L45-l50
get_latest_boot_version() {
  curl -s https://api.github.com/repos/boot-clj/boot/releases \
    | grep 'download_url.*boot\.sh' \
    | head -1 \
    | awk -F '/' '{print $(NF-1)}'
}

BOOT_SH_VERSION=$(get_latest_boot_version)
BOOT_SH_URL="https://github.com/boot-clj/boot/releases/download/${BOOT_SH_VERSION}/boot.sh"
mkdir -p "$1" "$2"
build=$(cd "$1/" && pwd)
cache=$(cd "$2/" && pwd)
env_dir="$3"

export BOOT_LOCAL_REPO="$cache/.m2/repository"
export BOOT_JVM_OPTIONS="-Xmx384m -Xss512k"

if [[ -f "$cache/boot" ]]
then
    echo "-----> Using cached version of boot"
else
    echo -n "-----> Downloading boot..."
    curl -sLo "$cache/boot.sh" "${BOOT_SH_URL}"
    chmod +x "$cache/boot.sh"
    echo " done"
    echo "-----> Bootstrapping..."
    "$cache/boot.sh" -C help 2>&1 | grep Retrieving | indent
    "$cache/boot.sh" -C -V 2>&1 | indent
    mv "$cache/boot.sh" "$cache/boot"
    echo "-----> Done bootstrapping"
fi

echo -n "-----> Copying boot..."
mkdir -p "$build/.bootbin"
cp "$cache/boot" "$build/.bootbin/"
echo " done"

if [[ -d "$env_dir" ]]
then
    # load the buildpack config vars
    for key in BOOTBUILD_CMD BOOTBUILD_CONFIG_WHITELIST
    do
        if [[ -f "$env_dir/$key" ]]
        then
            export "$key=$(cat "$env_dir/$key")"
        fi
    done
    # load the config vars allowed by BOOTBUILD_CONFIG_WHITELIST
    # (inspired by the way Clojure buildpack does it)
    if [[ -n "$BOOTBUILD_CONFIG_WHITELIST" ]]
    then
        for key in $BOOTBUILD_CONFIG_WHITELIST
        do
            if [[ -f "$env_dir/$key" ]]
            then
                export "$key=$(cat "$env_dir/$key")"
            fi
        done
    fi
fi

# By default, there's an expectation that the project's build.boot
# file defines 'build' task that takes care of all sorts of build-time
# concerns (e.g. pulling dependencies from repos eagerly). If a more
# complicated logic is desired at build-time, it can be overriden by
# specifying BOOTBUILD_CMD var that contains, say, a more complex boot
# pipeline. For instance:
# BOOTBUILD_CMD="boot foo -x -- bar --blah -q -- qaz"

boot_cmd=${BOOTBUILD_CMD:-"boot build"}
echo "-----> Running: $boot_cmd"
export PATH="$build/.bootbin:$PATH"
(cd $build && $boot_cmd 2>&1 | indent)

echo -n "-----> Copying jars..."
cp -R "$cache/.m2" "$build/.m2"
echo " done"

mkdir -p "$build/.profile.d"
cat << EOF > "$build/.profile.d/boot-env.sh"
export PATH="\$HOME/.bootbin:\$PATH"

limit=\$(ulimit -u)
case \$limit in
256)   # 1X Dyno
  default_java_opts="-Xmx384m -Xss512k"
  ;;
512)   # 2X Dyno
  default_java_opts="-Xmx768m"
  ;;
32768) # PX Dyno
  default_java_opts="-Xmx4g"
  ;;
*)
  default_java_opts="-Xmx384m -Xss512k"
  ;;
esac

export BOOT_JVM_OPTIONS=\${BOOT_JVM_OPTIONS:-"\${default_java_opts} -Dfile.encoding=UTF-8"}
EOF
